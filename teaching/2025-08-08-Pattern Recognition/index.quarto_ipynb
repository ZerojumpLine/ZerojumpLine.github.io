{
  "cells": [
    {
      "cell_type": "raw",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"Pattern Recognition 2025\"\n",
        "author: Zeju Li\n",
        "date: 2025-09-01\n",
        "slug: PR-2025\n",
        "image: featured.jpg\n",
        "categories:\n",
        "  - Ph.D.\n",
        "  - BME\n",
        "subtitle: \"An advanced, discussion-based course for Ph.D. students.\"\n",
        "description: ''\n",
        "format: \n",
        "  html: \n",
        "    page-layout: full\n",
        "links:\n",
        "- icon: file-richtext-fill\n",
        "  name: Canvas\n",
        "  url: https://elearning.fudan.edu.cn/courses/100620\n",
        "---"
      ],
      "id": "e3bc8775"
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "I teach a pattern recognition course for BME Ph.D. students. In this course, I will cover some advanced concepts of AI.\n",
        "\n",
        "## Description\n",
        "This is course for Ph.D. students with \n",
        "\n",
        "The course has a code as EST60033.02, discussions and feedbacks can be posted via [Canvas](https://elearning.fudan.edu.cn/courses/100620).\n",
        "\n",
        "The course happens.[You are free to do the coding at whereever you feel more free, but I will be in class to help you understand.]{.aside}\n",
        "\n",
        "\n",
        "\n",
        "## What will be learned\n",
        "\n",
        "### Representation Learning\n",
        "\n",
        "Plotly excels at visualizing machine learning concepts. Here's an advanced example showing decision boundaries and model predictions:"
      ],
      "id": "8d5d2ad0"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| output: true\n",
        "import plotly.graph_objects as go\n",
        "import numpy as np\n",
        "from sklearn.datasets import make_moons\n",
        "from sklearn.model_selection import train_test_split\n",
        "from sklearn.neighbors import KNeighborsClassifier\n",
        "\n",
        "# Parameters for visualization\n",
        "mesh_size = .02\n",
        "margin = 0.25\n",
        "\n",
        "# Load and split data\n",
        "X, y = make_moons(noise=0.3, random_state=0)\n",
        "X_train, X_test, y_train, y_test = train_test_split(\n",
        "    X, y.astype(str), test_size=0.25, random_state=0)\n",
        "\n",
        "# Create a mesh grid for decision boundary\n",
        "x_min, x_max = X[:, 0].min() - margin, X[:, 0].max() + margin\n",
        "y_min, y_max = X[:, 1].min() - margin, X[:, 1].max() + margin\n",
        "xrange = np.arange(x_min, x_max, mesh_size)\n",
        "yrange = np.arange(y_min, y_max, mesh_size)\n",
        "xx, yy = np.meshgrid(xrange, yrange)\n",
        "\n",
        "# Train K-Nearest Neighbors classifier\n",
        "clf = KNeighborsClassifier(15, weights='uniform')\n",
        "clf.fit(X, y)\n",
        "Z = clf.predict_proba(np.c_[xx.ravel(), yy.ravel()])[:, 1]\n",
        "Z = Z.reshape(xx.shape)\n",
        "\n",
        "# Define trace specifications for different data splits\n",
        "trace_specs = [\n",
        "    [X_train, y_train, '0', 'Train', 'square'],\n",
        "    [X_train, y_train, '1', 'Train', 'circle'],\n",
        "    [X_test, y_test, '0', 'Test', 'square-dot'],\n",
        "    [X_test, y_test, '1', 'Test', 'circle-dot']\n",
        "]\n",
        "\n",
        "# Create the main figure\n",
        "fig = go.Figure(data=[\n",
        "    go.Scatter(\n",
        "        x=X[y==label, 0], y=X[y==label, 1],\n",
        "        name=f'{split} Split, Label {label}',\n",
        "        mode='markers', marker_symbol=marker\n",
        "    )\n",
        "    for X, y, label, split, marker in trace_specs\n",
        "])\n",
        "\n",
        "# Style the markers\n",
        "fig.update_traces(\n",
        "    marker_size=12, marker_line_width=1.5,\n",
        "    marker_color=\"lightyellow\"\n",
        ")\n",
        "\n",
        "# Add decision boundary contour\n",
        "fig.add_trace(\n",
        "    go.Contour(\n",
        "        x=xrange,\n",
        "        y=yrange,\n",
        "        z=Z,\n",
        "        showscale=False,\n",
        "        colorscale='RdBu',\n",
        "        opacity=0.4,\n",
        "        name='Decision Boundary',\n",
        "        hoverinfo='skip'\n",
        "    )\n",
        ")\n",
        "\n",
        "# Apply beautiful styling\n",
        "fig.update_layout(\n",
        "    title=dict(\n",
        "        text=\"Machine Learning: Decision Boundary Visualization\",\n",
        "        font=dict(size=18, color=\"#2c3e50\"),\n",
        "        x=0.5\n",
        "    ),\n",
        "    xaxis_title=\"Feature 1\",\n",
        "    yaxis_title=\"Feature 2\",\n",
        "    width=700,\n",
        "    height=500,\n",
        "    plot_bgcolor='white',\n",
        "    font=dict(family=\"Arial, sans-serif\", size=12, color=\"#2c3e50\"),\n",
        "    showlegend=True,\n",
        "    legend=dict(\n",
        "        yanchor=\"top\", y=0.99, xanchor=\"left\", x=0.01,\n",
        "        bgcolor=\"rgba(255,255,255,0.9)\", bordercolor=\"#bdc3c7\", borderwidth=1\n",
        "    )\n",
        ")\n",
        "\n",
        "fig.show()"
      ],
      "id": "148b7056",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "This advanced visualization demonstrates Plotly's capability to show machine learning concepts including decision boundaries, training/test splits, and model predictions. The contour plot shows the decision boundary learned by the K-Nearest Neighbors classifier.\n",
        "\n",
        "### Discriminative Models\n",
        "\n",
        "Plotly also excels at 3D visualizations for regression problems. Here's an example using Support Vector Regression on the famous Iris dataset:"
      ],
      "id": "a3de059f"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| output: true\n",
        "import numpy as np\n",
        "import pandas as pd\n",
        "import plotly.express as px\n",
        "import plotly.graph_objects as go\n",
        "from sklearn.svm import SVR\n",
        "\n",
        "# Parameters for visualization\n",
        "mesh_size = .02\n",
        "margin = 0\n",
        "\n",
        "# Load the famous Iris dataset\n",
        "df = px.data.iris()\n",
        "\n",
        "# Prepare features and target\n",
        "X = df[['sepal_width', 'sepal_length']]\n",
        "y = df['petal_width']\n",
        "\n",
        "# Train Support Vector Regression model\n",
        "model = SVR(C=1.)\n",
        "model.fit(X, y)\n",
        "\n",
        "# Create a mesh grid for surface prediction\n",
        "x_min, x_max = X.sepal_width.min() - margin, X.sepal_width.max() + margin\n",
        "y_min, y_max = X.sepal_length.min() - margin, X.sepal_length.max() + margin\n",
        "xrange = np.arange(x_min, x_max, mesh_size)\n",
        "yrange = np.arange(y_min, y_max, mesh_size)\n",
        "xx, yy = np.meshgrid(xrange, yrange)\n",
        "\n",
        "# Generate predictions on the mesh grid\n",
        "# Convert mesh grid to DataFrame to avoid feature name warning\n",
        "mesh_df = pd.DataFrame(np.c_[xx.ravel(), yy.ravel()], columns=['sepal_width', 'sepal_length'])\n",
        "pred = model.predict(mesh_df)\n",
        "pred = pred.reshape(xx.shape)\n",
        "\n",
        "# Create the 3D scatter plot\n",
        "fig = px.scatter_3d(df, x='sepal_width', y='sepal_length', z='petal_width',\n",
        "                    title=\"3D Regression: Petal Width Prediction\",\n",
        "                    labels={'sepal_width': 'Sepal Width', 'sepal_length': 'Sepal Length', 'petal_width': 'Petal Width'})\n",
        "\n",
        "# Style the scatter points\n",
        "fig.update_traces(marker=dict(size=5, opacity=0.8))\n",
        "\n",
        "# Add the regression surface\n",
        "fig.add_traces(go.Surface(\n",
        "    x=xrange, \n",
        "    y=yrange, \n",
        "    z=pred, \n",
        "    name='Regression Surface',\n",
        "    opacity=0.6,\n",
        "    colorscale='Viridis'\n",
        "))\n",
        "\n",
        "# Apply beautiful 3D styling\n",
        "fig.update_layout(\n",
        "    scene=dict(\n",
        "        bgcolor='white',\n",
        "        xaxis=dict(showgrid=True, gridcolor='#ecf0f1'),\n",
        "        yaxis=dict(showgrid=True, gridcolor='#ecf0f1'),\n",
        "        zaxis=dict(showgrid=True, gridcolor='#ecf0f1'),\n",
        "        camera=dict(eye=dict(x=1.5, y=1.5, z=1.5))\n",
        "    ),\n",
        "    font=dict(family=\"Arial, sans-serif\", size=12, color=\"#2c3e50\"),\n",
        "    title=dict(\n",
        "        text=\"3D Regression: Petal Width Prediction\",\n",
        "        font=dict(size=18, color=\"#2c3e50\"),\n",
        "        x=0.5\n",
        "    ),\n",
        "    width=700,\n",
        "    height=500\n",
        ")\n",
        "\n",
        "fig.show()"
      ],
      "id": "e42efd5a",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "This 3D visualization demonstrates Plotly's advanced capabilities for regression analysis, showing both the actual data points and the learned regression surface. You can rotate, zoom, and interact with the 3D plot to explore the relationship between sepal dimensions and petal width.\n",
        "\n",
        "### Geneartive Models\n",
        "\n",
        "Flow matching is a powerful technique for learning continuous normalizing flows between probability distributions. Here's an interactive example showing the transformation from a Gaussian distribution to a more complex multimodal distribution:"
      ],
      "id": "78c00d2f"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| output: true\n",
        "import plotly.graph_objects as go\n",
        "import plotly.express as px\n",
        "from plotly.subplots import make_subplots\n",
        "import numpy as np\n",
        "from scipy.stats import multivariate_normal\n",
        "import pandas as pd\n",
        "\n",
        "# Set random seed for reproducibility\n",
        "np.random.seed(42)\n",
        "\n",
        "# Define the source and target distributions\n",
        "def source_density(x, y):\n",
        "    \"\"\"Source: 2D Gaussian distribution\"\"\"\n",
        "    mean = [0, 0]\n",
        "    cov = [[1, 0.3], [0.3, 1]]\n",
        "    return multivariate_normal.pdf(np.column_stack([x.ravel(), y.ravel()]), mean, cov).reshape(x.shape)\n",
        "\n",
        "def target_density(x, y):\n",
        "    \"\"\"Target: Mixture of two Gaussians\"\"\"\n",
        "    mean1, cov1 = [2, 2], [[0.5, 0.1], [0.1, 0.5]]\n",
        "    mean2, cov2 = [-2, -2], [[0.8, -0.2], [-0.2, 0.8]]\n",
        "    \n",
        "    pdf1 = multivariate_normal.pdf(np.column_stack([x.ravel(), y.ravel()]), mean1, cov1).reshape(x.shape)\n",
        "    pdf2 = multivariate_normal.pdf(np.column_stack([x.ravel(), y.ravel()]), mean2, cov2).reshape(x.shape)\n",
        "    return 0.6 * pdf1 + 0.4 * pdf2\n",
        "\n",
        "# Create grid for density visualization\n",
        "x = np.linspace(-4, 4, 50)\n",
        "y = np.linspace(-4, 4, 50)\n",
        "X, Y = np.meshgrid(x, y)\n",
        "\n",
        "# Generate flow matching trajectory\n",
        "def flow_matching_trajectory(t):\n",
        "    \"\"\"Simple linear interpolation between source and target\"\"\"\n",
        "    return (1 - t) * source_density(X, Y) + t * target_density(X, Y)\n",
        "\n",
        "# Create animation frames\n",
        "n_frames = 30\n",
        "frames = []\n",
        "for i in range(n_frames):\n",
        "    t = i / (n_frames - 1)\n",
        "    density = flow_matching_trajectory(t)\n",
        "    \n",
        "    # Create contour plot for each frame\n",
        "    frame = go.Frame(\n",
        "        data=[\n",
        "            go.Contour(\n",
        "                x=x, y=y, z=density,\n",
        "                colorscale='Plasma',\n",
        "                showscale=False,\n",
        "                opacity=0.9,\n",
        "                line=dict(width=0.5, color='rgba(255,255,255,0.3)'),\n",
        "                contours=dict(\n",
        "                    showlines=True,\n",
        "                    start=0,\n",
        "                    end=np.max(density),\n",
        "                    size=np.max(density)/12,\n",
        "                    coloring='heatmap'\n",
        "                )\n",
        "            )\n",
        "        ],\n",
        "        name=f\"frame_{i}\"\n",
        "    )\n",
        "    frames.append(frame)\n",
        "\n",
        "# Create initial figure\n",
        "fig = go.Figure(\n",
        "    data=[\n",
        "        go.Contour(\n",
        "            x=x, y=y, z=source_density(X, Y),\n",
        "            colorscale='Plasma',\n",
        "            showscale=False,\n",
        "            opacity=0.9,\n",
        "            line=dict(width=0.5, color='rgba(255,255,255,0.3)'),\n",
        "            contours=dict(\n",
        "                showlines=True,\n",
        "                start=0,\n",
        "                end=np.max(source_density(X, Y)),\n",
        "                size=np.max(source_density(X, Y))/12,\n",
        "                coloring='heatmap'\n",
        "            )\n",
        "        )\n",
        "    ],\n",
        "    frames=frames\n",
        ")\n",
        "\n",
        "# Add animation controls\n",
        "fig.update_layout(\n",
        "    title=dict(\n",
        "        text=\"Flow Matching: Gaussian → Multimodal Distribution\",\n",
        "        font=dict(size=20, color=\"#1a1a1a\", family=\"Inter, -apple-system, BlinkMacSystemFont, sans-serif\"),\n",
        "        x=0.5\n",
        "    ),\n",
        "    xaxis_title=\"X\",\n",
        "    yaxis_title=\"Y\",\n",
        "    width=700,\n",
        "    height=650,\n",
        "    plot_bgcolor='#fafafa',\n",
        "    paper_bgcolor='#ffffff',\n",
        "    font=dict(family=\"Inter, -apple-system, BlinkMacSystemFont, sans-serif\", size=13, color=\"#1a1a1a\"),\n",
        "    xaxis=dict(\n",
        "        gridcolor='rgba(0,0,0,0.1)',\n",
        "        linecolor='rgba(0,0,0,0.2)',\n",
        "        tickcolor='rgba(0,0,0,0.2)',\n",
        "        title_font=dict(size=14, color=\"#1a1a1a\")\n",
        "    ),\n",
        "    yaxis=dict(\n",
        "        gridcolor='rgba(0,0,0,0.1)',\n",
        "        linecolor='rgba(0,0,0,0.2)',\n",
        "        tickcolor='rgba(0,0,0,0.2)',\n",
        "        title_font=dict(size=14, color=\"#1a1a1a\")\n",
        "    ),\n",
        "    updatemenus=[\n",
        "        dict(\n",
        "            type=\"buttons\",\n",
        "            direction=\"left\",\n",
        "            buttons=list([\n",
        "                dict(\n",
        "                    args=[None, {\"frame\": {\"duration\": 100, \"redraw\": True},\n",
        "                                \"fromcurrent\": True, \"transition\": {\"duration\": 50}}],\n",
        "                    label=\"▶️ Play\",\n",
        "                    method=\"animate\"\n",
        "                ),\n",
        "                dict(\n",
        "                    args=[[None], {\"frame\": {\"duration\": 0, \"redraw\": True},\n",
        "                                   \"mode\": \"immediate\", \"transition\": {\"duration\": 0}}],\n",
        "                    label=\"⏸️ Pause\",\n",
        "                    method=\"animate\"\n",
        "                )\n",
        "            ]),\n",
        "            pad={\"r\": 15, \"t\": 100},\n",
        "            showactive=False,\n",
        "            x=0.2,\n",
        "            xanchor=\"right\",\n",
        "            y=0.10,\n",
        "            yanchor=\"top\",\n",
        "            bgcolor='rgba(255,255,255,0.9)',\n",
        "            bordercolor='rgba(0,0,0,0.1)',\n",
        "            borderwidth=1\n",
        "        )\n",
        "    ],\n",
        "    sliders=[\n",
        "        dict(\n",
        "            active=0,\n",
        "            yanchor=\"top\",\n",
        "            xanchor=\"left\",\n",
        "            currentvalue={\"font\": {\"size\": 16, \"color\": \"#1a1a1a\", \"family\": \"Inter, sans-serif\"}, \"prefix\": \"Time: \", \"visible\": True, \"xanchor\": \"right\"},\n",
        "            transition={\"duration\": 300, \"easing\": \"cubic-in-out\"},\n",
        "            pad={\"b\": 20, \"t\": 60},\n",
        "            len=0.9,\n",
        "            x=0.05,\n",
        "            y=0,\n",
        "            bgcolor='rgba(255,255,255,0.9)',\n",
        "            bordercolor='rgba(0,0,0,0.1)',\n",
        "            borderwidth=1,\n",
        "            tickcolor='#6366f1',\n",
        "            ticklen=8,\n",
        "            tickwidth=2,\n",
        "            steps=[\n",
        "                dict(\n",
        "                    args=[[f\"frame_{i}\"], {\"frame\": {\"duration\": 100, \"redraw\": True},\n",
        "                                           \"mode\": \"immediate\", \"transition\": {\"duration\": 50}}],\n",
        "                    label=f\"{i/(n_frames-1):.2f}\",\n",
        "                    method=\"animate\"\n",
        "                )\n",
        "                for i in range(n_frames)\n",
        "            ]\n",
        "        )\n",
        "    ]\n",
        ")\n",
        "\n",
        "# Add annotations for source and target\n",
        "fig.add_annotation(\n",
        "    x=0, y=0, xref=\"x\", yref=\"y\",\n",
        "    text=\"Source<br>(Gaussian)\",\n",
        "    showarrow=True,\n",
        "    arrowhead=2,\n",
        "    arrowsize=1.2,\n",
        "    arrowwidth=2.5,\n",
        "    arrowcolor=\"#6366f1\",\n",
        "    ax=25, ay=-35,\n",
        "    font=dict(size=13, color=\"#1a1a1a\", family=\"Inter, sans-serif\"),\n",
        "    bgcolor='rgba(255,255,255,0.9)',\n",
        "    bordercolor='rgba(99,102,241,0.3)',\n",
        "    borderwidth=1\n",
        ")\n",
        "\n",
        "fig.add_annotation(\n",
        "    x=2, y=2, xref=\"x\", yref=\"y\",\n",
        "    text=\"Target<br>(Multimodal)\",\n",
        "    showarrow=True,\n",
        "    arrowhead=2,\n",
        "    arrowsize=1.2,\n",
        "    arrowwidth=2.5,\n",
        "    arrowcolor=\"#ef4444\",\n",
        "    ax=25, ay=-35,\n",
        "    font=dict(size=13, color=\"#1a1a1a\", family=\"Inter, sans-serif\"),\n",
        "    bgcolor='rgba(255,255,255,0.9)',\n",
        "    bordercolor='rgba(239,68,68,0.3)',\n",
        "    borderwidth=1\n",
        ")\n",
        "\n",
        "fig.show()"
      ],
      "id": "741f982d",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "This interactive animation demonstrates the concept of flow matching, where we learn a continuous transformation between two probability distributions. The animation shows how particles (represented by the density contours) flow from a simple Gaussian distribution to a more complex multimodal distribution. You can use the play/pause buttons or the slider to control the animation and observe the smooth transformation process.\n",
        "\n",
        "Flow matching is particularly useful in generative modeling, where we want to learn to transform noise into realistic data samples while maintaining the ability to compute exact likelihoods and perform efficient sampling.\n",
        "\n",
        "## Course Components\n",
        "\n",
        "### Presentation Sections\n",
        "\n",
        "::: {.presentation-info}\n",
        "- **Group Size**: Maximum 2 people per group\n",
        "- **Class Size**: ~20 students\n",
        "- **Presentation Slots**: 5 sessions throughout the semester\n",
        "- **Format**: Interactive presentations with Q&A sessions\n",
        ":::\n",
        "\n",
        "### Coding Sections\n",
        "\n",
        "::: {.coding-info}\n",
        "- **Hands-on Programming**: Practical implementation of algorithms\n",
        "- **Languages**: Python, with optional R/Julia\n",
        "- **Environment**: Jupyter notebooks and Google Colab\n",
        "- **Assessment**: Code quality, documentation, and results\n",
        ":::\n",
        "\n",
        "### Final Project\n",
        "\n",
        "::: {.course-description}\n",
        "**Due Date**: Week 17\n",
        "\n",
        "The final project is a comprehensive research project where students will:\n",
        "- Choose a pattern recognition problem\n",
        "- Implement and compare multiple algorithms\n",
        "- Write a technical report\n",
        "- Present findings to the class\n",
        ":::\n",
        "\n",
        "## Schedule\n",
        "\n",
        "### Module 1: Basic Theory\n",
        "\n",
        "| Week | Date | Lesson 1 | Lesson 2 | Lesson 3 | Materials |\n",
        "|:----:|:----:|:--------:|:--------:|:--------:|:---------:|\n",
        "| **1** | 09/09/2025 | *Lecture* | *Lecture* | *Lecture* | Slides |\n",
        "| **2** | 16/09/2025 | *Lecture* | <span style=\"color: darkred !important;\">*Presentation I*</span> | *Coding I* | Slides, Code, Answer |\n",
        "| **3** | 23/09/2025 | *Reading*^1^ | *Reading*^2^ | *Reading*^3^ | |\n",
        "| **4** | 30/09/2025 | *Reading*^4^ | *Reading*^5^ | *Reading*^6^ | |\n",
        "\n",
        "^1^ Gaussian Mixtures and Dead Leave [Those papers are fundementals to this research fiel and a must know for a qualified Ph.D. student for AI related majors.]{.aside}\n",
        "\n",
        "### Module 2: Discriminative Models\n",
        "\n",
        "| Week | Date | Lesson 1 | Lesson 2 | Lesson 3 | Materials |\n",
        "|:----:|:----:|:--------:|:--------:|:--------:|:---------:|\n",
        "| **5** | 07/10/2025 | *Lecture* | *Lecture* | *Lecture* | Slides |\n",
        "| **6** | 14/10/2025 | *Lecture* |<span style=\"color: darkred !important;\">*Presentation II*</span> | *Coding II* | Slides, Code, Answer |\n",
        "| **7** | 21/10/2025 | *Reading*^7^ | *Reading*^8^ | *Reading*^9^ | |\n",
        "\n",
        "### Module 3: Reinforcement Learning\n",
        "\n",
        "| Week | Date | Lesson 1 | Lesson 2 | Lesson 3 | Materials |\n",
        "|:----:|:----:|:--------:|:--------:|:--------:|:---------:|\n",
        "| **8** | 28/10/2025 | *Lecture* | *Lecture* | *Lecture* | Slides |\n",
        "| **9** | 04/11/2025 | *Lecture* | <span style=\"color: darkred !important;\">*Presentation III*</span> | *Coding III* | Slides, Code, Answer |\n",
        "| **10** | 11/11/2025 | *Reading*^10^ | *Reading*^11^ | *Reading*^12^ | |\n",
        "\n",
        "### Module 4: Generative Models\n",
        "\n",
        "| Week | Date | Lesson 1 | Lesson 2 | Lesson 3 | Materials |\n",
        "|:----:|:----:|:--------:|:--------:|:--------:|:---------:|\n",
        "| **11** | 18/11/2025 | *Lecture* | *Lecture* | *Lecture* | Slides |\n",
        "| **12** | 25/11/2025 | *Reading*^13^ | *Reading*^14^ | *Reading*^15^ | |\n",
        "| **13** | 02/12/2025 | *Lecture* | <span style=\"color: darkred !important;\">*Presentation IV*</span> | *Coding IV* | Slides, Code, Answer |\n",
        "\n",
        "### Module 5: Emerging Topics\n",
        "\n",
        "| Week | Date | Lesson 1 | Lesson 2 | Lesson 3 | Materials |\n",
        "|:----:|:----:|:--------:|:--------:|:--------:|:---------:|\n",
        "| **14** | 09/12/2025 | *Lecture* | *Lecture* | *Lecture* | Slides |\n",
        "| **15** | 16/12/2025 | *Lecture* | <span style=\"color: darkred !important;\">*Presentation V*</span> | *Coding V* | Slides, Code, Answer |\n",
        "| **16** | 23/12/2025 | *Reading*^16^ | *Reading*^17^ | *Reading*^18^ | |\n",
        "\n",
        "\n",
        "### Grading Policy\n",
        "\n",
        "| Component | Weight | Description |\n",
        "|:---------:|:------:|:------------|\n",
        "| **Presentations** | 25% | Quality of presentation and engagement |\n",
        "| **Coding Assignments** | 30% | Implementation and documentation |\n",
        "| **Final Project** | 35% | Research depth and technical writing |\n",
        "| **Participation** | 10% | Class engagement and discussions |\n",
        "\n",
        "\n",
        "## Recommended Reading Materials\n",
        "\n",
        "### Core Pattern Recognition & Machine Learning\n",
        "- [Pattern Recognition and Machine Learning](https://www.microsoft.com/en-us/research/publication/pattern-recognition-machine-learning/) - Christopher Bishop's comprehensive textbook on pattern recognition\n",
        "- [机器学习](https://github.com/Mikoto10032/DeepLearning/blob/master/books/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%91%A8%E5%BF%97%E5%8D%8E.pdf) - 周志华's foundational machine learning textbook (in Chinese)\n",
        "\n",
        "### Deep Learning\n",
        "- [Deep Learning](https://www.deeplearningbook.org/) - Ian Goodfellow, Yoshua Bengio, and Aaron Courville's authoritative deep learning textbook\n",
        "- [Dive into Deep Learning](https://d2l.ai/) - Interactive deep learning book with practical implementations\n",
        "\n",
        "### Mathematical Foundations\n",
        "- [Mathematics for Machine Learning](https://mml-book.github.io/) - Essential mathematical concepts for machine learning\n",
        "- [Machine Learning: A Probabilistic Perspective](https://github.com/Jing--Li/book/blob/master/ML%20Machine%20Learning-A%20Probabilistic%20Perspective.pdf) - Kevin Murphy's detailed treatment of machine learning from a probabilistic viewpoint\n",
        "\n",
        "### Medical Imaging & Domain-Specific Applications\n",
        "- [Generative Machine Learning Models in Medical Image Computing](https://link.springer.com/book/10.1007/978-3-031-80965-1) - Specialized book on generative models in medical imaging\n",
        "- [Machine Learning in MRI](https://shop.elsevier.com/books/machine-learning-in-mri/kuestner/978-0-443-14109-6) - Focused on machine learning applications in magnetic resonance imaging"
      ],
      "id": "076ef08b"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "/opt/anaconda3/share/jupyter/kernels/python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}